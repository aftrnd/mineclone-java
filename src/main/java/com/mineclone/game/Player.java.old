package com.mineclone.game;

import org.joml.Vector3f;

/**
 * Player entity with physics-based movement system.
 * Based on Minecraft's LocalPlayer implementation with proper delta-time physics.
 * 
 * Key improvements over naive implementation:
 * - Separate movement intent from physics velocity
 * - Proper ground detection via collision, not velocity
 * - Friction applied after movement, before next frame
 * - Delta-time based movement calculations
 * - AABB collision detection with world
 */
public class Player {
    // Position and movement state
    private Vector3f position;
    private Vector3f velocity;
    private Vector3f rotation;
    
    // Previous frame state for interpolation (Minecraft-style)
    private Vector3f lastPosition;
    private Vector3f lastRotation;
    
    // Physics state
    private boolean onGround;
    private boolean horizontalCollision;
    private boolean flying;
    
    // Flying state tracking for double-tap detection
    private long lastSpacePressTime;
    private static final long DOUBLE_TAP_TIME_MS = 300;  // Time window for double-tap
    
    // Player constants (Minecraft standard dimensions)
    private static final float PLAYER_EYE_HEIGHT = 1.62f;
    private static final float PLAYER_WIDTH = 0.6f;
    private static final float PLAYER_HEIGHT = 1.8f;
    
    // === MINECRAFT EXACT PHYSICS CONSTANTS ===
    // All values are PER TICK (Minecraft runs at 20 ticks per second)
    
    // Movement speeds (blocks per tick)
    private static final float WALK_SPEED = 0.1f;             // Minecraft: 0.1 blocks/tick base walking
    private static final float SPRINT_MULTIPLIER = 1.3f;      // Sprint is 30% faster
    private static final float FLY_SPEED = 0.05f;             // Minecraft: 0.05 blocks/tick base flying
    private static final float FLY_SPRINT_MULTIPLIER = 2.0f;  // Flying sprint is 2x faster
    
    // Vertical movement (blocks per tick)
    private static final float JUMP_VELOCITY = 0.42f;         // Minecraft: 0.42 blocks/tick
    
    // Slipperiness factor (how input translates to velocity)
    private static final float SLIPPERINESS = 0.6f;           // Minecraft: normal blocks = 0.6

    public Player() {
        // Spawn at Y=65 (one block above the grass at Y=64)
        position = new Vector3f(8, 65, 8);
        velocity = new Vector3f(0, 0, 0);
        // Start looking straight ahead (pitch=0, yaw=0)
        // Pitch: 0=straight ahead, positive=down, negative=up
        // Yaw: 0=north, 90=east, 180=south, 270=west
        rotation = new Vector3f(0, 0, 0);  // Looking straight north, level
        lastPosition = new Vector3f(position);
        lastRotation = new Vector3f(rotation);
        onGround = false;
        horizontalCollision = false;
        flying = false;
        lastSpacePressTime = 0;
    }

    /**
     * Simple physics update without collision (collision handled externally).
     * Just updates last position for interpolation.
     */
    public void updateLastState() {
        lastPosition.set(position);
        lastRotation.set(rotation);
    }
    
    /**
     * Set ground state (called by external collision system).
     */
    public void setOnGround(boolean onGround) {
        this.onGround = onGround;
    }

    /**
     * Apply movement input - Minecraft's EXACT per-tick algorithm!
     * Called once per game tick (20 TPS).
     */
    public void move(float forward, float right) {
        if (forward == 0 && right == 0) return;
        
        // Calculate movement direction based on camera rotation
        float yawRad = (float) Math.toRadians(rotation.y);
        float sinYaw = (float) Math.sin(yawRad);
        float cosYaw = (float) Math.cos(yawRad);
        
        // Calculate desired movement direction
        float moveX = sinYaw * forward + cosYaw * right;
        float moveZ = -cosYaw * forward + sinYaw * right;
        
        // Normalize diagonal movement (prevent faster diagonal movement)
        float length = (float) Math.sqrt(moveX * moveX + moveZ * moveZ);
        if (length > 0) {
            moveX /= length;
            moveZ /= length;
        }
        
        // Minecraft's movement formula per tick:
        // Actual Minecraft: steady state velocity = input * 0.1 * 0.6 * 0.91 / (1 - 0.91) ‚âà 0.6
        // But this doesn't match observed 4.3 m/s (0.215 blocks/tick) in Minecraft
        // Empirically, 0.21 movement factor gives correct 4.3 m/s:
        float movementSpeed = getMovementSpeed();
        float movementFactor = movementSpeed * SLIPPERINESS * 0.21f;  // Tuned to match 4.3 m/s walk speed
        
        // Add to velocity (friction applied separately later)
        velocity.x += moveX * movementFactor;
        velocity.z += moveZ * movementFactor;
    }

    /**
     * Jump if on ground - Minecraft's exact jump velocity per tick.
     */
    public void jump() {
        if (onGround) {
            System.out.println("üöÄ JUMP! Setting velocity.y = " + JUMP_VELOCITY + " blocks/tick (was: " + velocity.y + ")");
            velocity.y = JUMP_VELOCITY;  // 0.42 blocks/tick
            onGround = false;
        } else {
            System.out.println("‚ùå JUMP FAILED - not on ground (velocity.y = " + velocity.y + ")");
        }
    }

    /**
     * Rotate player view (camera).
     */
    public void rotate(float dyaw, float dpitch) {
        rotation.y += dyaw;
        rotation.x += dpitch;

        // Clamp pitch to prevent over-rotation
        rotation.x = Math.max(-90, Math.min(90, rotation.x));
        
        // Normalize yaw to 0-360
        rotation.y = rotation.y % 360;
        if (rotation.y < 0) rotation.y += 360;
    }

    // Getters
    public Vector3f getPosition() { return position; }
    public Vector3f getLastPosition() { return lastPosition; }
    public Vector3f getRotation() { return rotation; }
    public Vector3f getLastRotation() { return lastRotation; }
    public Vector3f getVelocity() { return velocity; }
    public boolean isOnGround() { return onGround; }
    public boolean hasHorizontalCollision() { return horizontalCollision; }
    public float getEyeHeight() { return PLAYER_EYE_HEIGHT; }
    
    public boolean isFlying() { return flying; }
    
    /**
     * Toggle flying mode (called on double-tap space).
     */
    public void toggleFlying() {
        flying = !flying;
        if (flying) {
            // When starting to fly, zero vertical velocity
            velocity.y = 0;
        }
        System.out.println("‚úàÔ∏è FLYING MODE: " + (flying ? "ON" : "OFF"));
    }
    
    /**
     * Handle space bar press for jump/fly logic.
     * Returns true if this was a double-tap.
     */
    public boolean onSpacePressed() {
        long currentTime = System.currentTimeMillis();
        long timeSinceLastPress = currentTime - lastSpacePressTime;
        
        boolean isDoubleTap = timeSinceLastPress < DOUBLE_TAP_TIME_MS && timeSinceLastPress > 0;
        lastSpacePressTime = currentTime;
        
        if (isDoubleTap) {
            toggleFlying();
            return true;
        }
        return false;
    }
    
    /**
     * Get movement speed based on current state (blocks per tick).
     */
    public float getMovementSpeed() {
        return flying ? FLY_SPEED : WALK_SPEED;
    }
}
